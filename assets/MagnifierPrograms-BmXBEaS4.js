import{n as M}from"./WGLContainer-CosurzxA.js";import{t as pt}from"./CircularArray-DfLrgW_-.js";import{bC as nt,eF as _t,xZ as gt,x_ as V,gc as x,vA as vt,x$ as wt,S as R,g as p,y as v,i as L,hT as rt,hR as ft,y0 as yt,cS as bt,kd as H,cF as j,fG as dt,y1 as X,d9 as Mt,dy as xt,dL as Tt,y2 as St,y3 as $t,l8 as it,y4 as Ct,l9 as zt,y5 as Et,cR as F,y6 as Rt,y7 as st,y8 as Lt,y9 as At,u as q,ya as ht}from"./index-nBWeBKPv.js";import{t as Zt}from"./AttributeStore-DOjVp8d7.js";import{e as kt}from"./ProgramTemplate-B9wT6rfn.js";const Ht={shaders:{vertexShader:M("bitBlit/bitBlit.vert"),fragmentShader:M("bitBlit/bitBlit.frag")},attributes:new Map([["a_pos",0],["a_tex",1]])},jt={shaders:{vertexShader:M("stencil/stencil.vert"),fragmentShader:M("stencil/stencil.frag")},attributes:new Map([["a_pos",0]])},Qt={shaders:{vertexShader:M("highlight/textured.vert"),fragmentShader:M("highlight/highlight.frag")},attributes:new Map([["a_position",0],["a_texcoord",1]])},Jt={shaders:{vertexShader:M("highlight/textured.vert"),fragmentShader:M("highlight/blur.frag")},attributes:new Map([["a_position",0],["a_texcoord",1]])},f=nt("esri-2d-profiler");let Kt=class{constructor(t,e){if(this._events=new _t,this._entries=new Map,this._timings=new pt(10),this._currentContainer=null,this._currentPass=null,this._currentBrush=null,this._currentSummary=null,!f)return;this._ext=gt(t.gl,{}),this._debugOutput=e;const i=t.gl;if(!this.enableCommandLogging)return;let n;for(n in i)if(typeof i[n]=="function"){const o=i[n],h=n.includes("draw");i[n]=(...r)=>(this._events.emit("command",{container:this._currentContainer,pass:this._currentPass,brush:this._currentBrush,method:n,args:r,isDrawCommand:h}),this._currentSummary&&(this._currentSummary.commands++,h&&this._currentSummary.drawCommands++),o.apply(i,r))}}get enableCommandLogging(){return!(typeof f=="object"&&f.disableCommands)}recordContainerStart(t){f&&(this._currentContainer=t)}recordContainerEnd(){f&&(this._currentContainer=null)}recordPassStart(t){f&&(this._currentPass=t,this._initSummary())}recordPassEnd(){f&&(this._currentPass=null,this._emitSummary())}recordBrushStart(t){f&&(this._currentBrush=t)}recordBrushEnd(){f&&(this._currentBrush=null)}recordStart(t){if(f&&this._ext!=null){if(this._entries.has(t)){const i=this._entries.get(t),n=this._ext.resultAvailable(i.query),o=this._ext.disjoint();if(n&&!o){const h=this._ext.getResult(i.query)/1e6;let r=0;if(this._timings.enqueue(h)!=null){const l=this._timings.entries,c=l.length;let _=0;for(const u of l)_+=u;r=_/c}const a=h.toFixed(2),m=r?r.toFixed(2):"--";this.enableCommandLogging?(console.groupCollapsed(`Frame report for ${t}, ${a} ms (${m} last 10 avg)
${i.commandsLen} Commands (${i.drawCommands} draw)`),console.log("RenderPass breakdown: "),console.table(i.summaries),console.log("Commands: ",i.commands),console.groupEnd()):console.log(`Frame report for ${t}, ${a} ms (${m} last 10 avg)`),this._debugOutput.innerHTML=`${a} (${m})`}for(const h of i.handles)h.remove();this._ext.deleteQuery(i.query),this._entries.delete(t)}const e={name:t,query:this._ext.createQuery(),commands:[],commandsLen:0,drawCommands:0,summaries:[],handles:[]};this.enableCommandLogging&&(e.handles.push(this._events.on("command",i=>{e.commandsLen++,e.commands.push(i),i.isDrawCommand&&e.drawCommands++})),e.handles.push(this._events.on("summary",i=>{e.summaries.push(i)}))),this._ext.beginTimeElapsed(e.query),this._entries.set(t,e)}}recordEnd(t){f&&this._ext!=null&&this._entries.has(t)&&this._ext.endTimeElapsed()}_initSummary(){this.enableCommandLogging&&(this._currentSummary={container:this._currentContainer,pass:this._currentPass,drawCommands:0,commands:0})}_emitSummary(){this.enableCommandLogging&&this._currentSummary&&this._events.emit("summary",this._currentSummary)}};const y=1,Y=0,B=1,D=2;let It=class{constructor(t,e,i){this._debugMap=new Map,this._width=t*i,this._height=e*i,this._pixelRatio=i;const n=Math.ceil(this._width/y),o=Math.ceil(this._height/y);this._cols=n,this._rows=o,this._cells=Zt.create(n*o)}insertMetrics(t){this._markMetrics(t)}hasCollision(t){let e=0;for(const{computedX:i,computedY:n,width:o,height:h}of t.bounds){const r=(o+V)*this._pixelRatio,a=(h+V)*this._pixelRatio;switch(this._collide(i,n,r,a)){case D:return D;case B:e++}}return e===t.bounds.length?B:Y}getCellId(t,e){return t+e*this._cols}has(t){return this._cells.has(t)}hasRange(t,e){return this._cells.hasRange(t,e)}set(t){this._cells.set(t)}setRange(t,e){this._cells.setRange(t,e)}_collide(t,e,i,n){const o=t-i/2,h=e-n/2,r=o+i,a=h+n;if(r<0||a<0||o>this._width||h>this._height)return B;const m=x(Math.floor(o/y),0,this._cols),l=x(Math.floor(h/y),0,this._rows),c=x(Math.ceil(r/y),0,this._cols),_=x(Math.ceil(a/y),0,this._rows);for(let u=l;u<=_;u++)for(let d=m;d<=c;d++){const g=this.getCellId(d,u);if(this.has(g))return D}return Y}_mark(t,e,i,n,o){const h=t-i/2,r=e-n/2,a=h+i,m=r+n,l=x(Math.floor(h/y),0,this._cols),c=x(Math.floor(r/y),0,this._rows),_=x(Math.ceil(a/y),0,this._cols),u=x(Math.ceil(m/y),0,this._rows);for(let d=c;d<=u;d++)for(let g=l;g<=_;g++){const A=this.getCellId(g,d);this._debugMap.set(A,o),this.set(A)}return!1}_markMetrics(t){for(const{computedX:e,computedY:i,width:n,height:o}of t.bounds){const h=(n+V)*this._pixelRatio,r=(o+V)*this._pixelRatio;this._mark(e,i,h,r,t.entityTexel)}}};const Z=254,O=255,k=0;function $(s,t){const e=s.children.slice();e.sort((i,n)=>i.tileAge-n.tileAge),e.forEach(i=>{i.labelMetrics!=null&&i.isReady&&t(i,i.labelMetrics)})}function lt(s,t){return(!s.minScale||s.minScale>=t)&&(!s.maxScale||s.maxScale<=t)}let Pt=class{run(t,e,i,n){var h;const o=[];for(let r=t.length-1;r>=0;r--){const a=t[r];(h=a.labelingCollisionInfos)!=null&&h.length&&o.push(...a.labelingCollisionInfos)}nt("esri-2d-update-debug")&&o.length&&console.debug("CollisionEngine.run"),this._transformMetrics(o),this._runCollision(o,e,i,n);for(const r of o)r.container.requestRender()}_runCollision(t,e,i,n){const[o,h]=e.state.size,r=new It(o,h,e.pixelRatio);for(const{container:a,deconflictionEnabled:m,visible:l}of t){const c=a.attributeView;m?l?(this._prepare(a),this._collideVisible(r,a,i,n),this._collideInvisible(r,a)):$(a,(_,u)=>{for(const d of u)c.setLabelMinZoom(d.entityTexel,O)}):$(a,(_,u)=>{for(const d of u)lt(d,i)?(c.setLabelMinZoom(d.entityTexel,k),l&&r.insertMetrics(d)):c.setLabelMinZoom(d.entityTexel,Z)})}}_isFiltered(t,e,i){const n=e.getFilterFlags(t),o=!i.hasFilter||!!(n&vt),h=i.featureEffect==null||i.featureEffect.excludedLabelsVisible||!!(n&wt);return!(o&&h)}_prepare(t){const e=t.attributeView,i=new Set;$(t,(n,o)=>{for(const h of o){const r=h.entityTexel;if(!i.has(r)){if(i.add(r),this._isFiltered(r,e,t.layerView)){e.setLabelMinZoom(r,Z);continue}e.getLabelMinZoom(r)!==k?e.setLabelMinZoom(r,O):e.setLabelMinZoom(r,k)}}})}_collideVisible(t,e,i,n){const o=e.attributeView,h=new Set;$(e,(r,a)=>{for(let m=0;m<a.length;m++){const l=a[m].entityTexel;if(h.has(l))continue;if(r.key.level!==n){o.setLabelMinZoom(l,Z),h.add(l);continue}if(!lt(a[m],i)){o.setLabelMinZoom(l,Z),h.add(l);continue}if(o.getLabelMinZoom(l)!==0){h.add(l);continue}let c=!1,_=!0;const u=m;let d=m;for(;d<a.length;d++){const g=a[d];if(g.entityTexel!==l)break;if(!c)switch(t.hasCollision(g)){case B:break;case D:c=!0,_=!1;break;case Y:_=!1}}if(!c)for(let g=u;g<d;g++)t.insertMetrics(a[g]);m=d-1,_||(h.add(l),o.setLabelMinZoom(l,c?Z:k))}})}_collideInvisible(t,e){const i=e.attributeView,n=new Set;$(e,(o,h)=>{for(let r=0;r<h.length;r++){const a=h[r].entityTexel;if(n.has(a))continue;if(i.getLabelMinZoom(a)!==O){n.add(a);continue}let m=!1,l=!0;const c=r;let _=r;for(;_<h.length;_++){const u=h[_];if(u.entityTexel!==a)break;if(!m)switch(t.hasCollision(u)){case B:break;case D:m=!0,l=!1;break;case Y:l=!1}}if(!m)for(let u=c;u<_;u++)t.insertMetrics(h[u]);r=_-1,l||(n.add(a),i.setLabelMinZoom(a,m?O:k))}})}_transformMetrics(t){for(const{container:e,geometryType:i,vvEvaluators:n}of t)$(e,(o,h)=>{var l;const r=e.attributeView,a=o.transforms.labelMat2d;a[4]=Math.round(a[4]),a[5]=Math.round(a[5]);const m=i==="polyline";for(const c of h){const{entityTexel:_,anchorX:u,anchorY:d}=c;let g=((l=c.referenceBounds)==null?void 0:l.size)??0;const A=n[0];if(A!=null){const w=A(r.getVVSize(_));g=isNaN(w)||w==null||w===1/0?g:w}const ot=c.directionX*(g/2),at=c.directionY*(g/2);for(const w of c.bounds){let Q=u,J=d;if(m){let T=Q+w.x+ot,S=J+w.y+at;T=a[0]*T+a[2]*S+a[4],S=a[1]*T+a[3]*S+a[5],w.computedX=Math.floor(T),w.computedY=Math.floor(S)}else{Q=a[0]*u+a[2]*d+a[4],J=a[1]*u+a[3]*d+a[5];const T=Q+w.x+ot,S=J+w.y+at;w.computedX=T,w.computedY=S}}}})}};const Nt=32;let I=class extends R{constructor(t){super(t),this._lastUpdate=0,this.collisionEngine=new Pt,this.lastUpdateId=-1,this.updateRequested=!1,this.view=null}get updating(){return nt("esri-2d-log-updating")&&console.log(`Updating LabelManager ${this.updateRequested}:
-> updateRequested: ${this.updateRequested}`),this.updateRequested}update(t){const e=performance.now();e-this._lastUpdate>=Nt?(this._lastUpdate=e,this.doUpdate(t)):this.requestUpdate()}viewChange(){this.requestUpdate()}requestUpdate(){var t;this.updateRequested||(this.updateRequested=!0,(t=this.view)==null||t.requestUpdate())}processUpdate(t){this.updateRequested&&(this.updateRequested=!1,this.update(t))}doUpdate(t){const e=this.view;if(e)try{const i=t.state.scale,n=e.featuresTilingScheme.getClosestInfoForScale(i).level;this.collisionEngine.run(e.allLayerViews.items,t,i,n)}catch{}}};p([v()],I.prototype,"updateRequested",void 0),p([v()],I.prototype,"updating",null),p([v()],I.prototype,"view",void 0),I=p([L("esri.views.2d.LabelManager")],I);const U="esri-zoom-box",G={container:`${U}__container`,overlay:`${U}__overlay`,background:`${U}__overlay-background`,box:`${U}__outline`},K={zoom:"Shift",counter:"Ctrl"};let P=class extends R{constructor(s){super(s),this._container=null,this._overlay=null,this._backgroundShape=null,this._boxShape=null,this._box={x:0,y:0,width:0,height:0},this._rafId=null,this._redraw=this._redraw.bind(this)}destroy(){this.view=null}set view(s){this.removeAllHandles(),this._destroyOverlay(),this._set("view",s),s&&this.addHandles([s.on("drag",[K.zoom],t=>this._handleDrag(t,1),rt.INTERNAL),s.on("drag",[K.zoom,K.counter],t=>this._handleDrag(t,-1),rt.INTERNAL)])}_start(){this._createContainer(),this._createOverlay(),this.navigation.begin()}_update(s,t,e,i){this._box.x=s,this._box.y=t,this._box.width=e,this._box.height=i,this._rafId||(this._rafId=requestAnimationFrame(this._redraw))}_end(s,t,e,i,n){const o=this.view,h=o.toMap(ft(s+.5*e,t+.5*i));let r=Math.max(e/o.width,i/o.height);n===-1&&(r=1/r),this._destroyOverlay(),this.navigation.end(),o.goTo({center:h,scale:o.scale*r})}_updateBox(s,t,e,i){const n=this._boxShape;n.setAttributeNS(null,"x",""+s),n.setAttributeNS(null,"y",""+t),n.setAttributeNS(null,"width",""+e),n.setAttributeNS(null,"height",""+i),n.setAttributeNS(null,"class",G.box)}_updateBackground(s,t,e,i){this._backgroundShape.setAttributeNS(null,"d",this._toSVGPath(s,t,e,i,this.view.width,this.view.height))}_createContainer(){const s=document.createElement("div");s.className=G.container,this.view.root.appendChild(s),this._container=s}_createOverlay(){const s=this.view.width,t=this.view.height,e=document.createElementNS("http://www.w3.org/2000/svg","path");e.setAttributeNS(null,"d","M 0 0 L "+s+" 0 L "+s+" "+t+" L 0 "+t+" Z"),e.setAttributeNS(null,"class",G.background);const i=document.createElementNS("http://www.w3.org/2000/svg","rect"),n=document.createElementNS("http://www.w3.org/2000/svg","svg");n.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink","http://www.w3.org/1999/xlink"),n.setAttributeNS(null,"class",G.overlay),n.appendChild(e),n.appendChild(i),this._container.appendChild(n),this._backgroundShape=e,this._boxShape=i,this._overlay=n}_destroyOverlay(){this._container&&this._container.parentNode&&this._container.parentNode.removeChild(this._container),this._container=this._backgroundShape=this._boxShape=this._overlay=null}_toSVGPath(s,t,e,i,n,o){const h=s+e,r=t+i;return"M 0 0 L "+n+" 0 L "+n+" "+o+" L 0 "+o+" ZM "+s+" "+t+" L "+s+" "+r+" L "+h+" "+r+" L "+h+" "+t+" Z"}_handleDrag(s,t){const e=s.x,i=s.y,n=s.origin.x,o=s.origin.y;let h,r,a,m;switch(e>n?(h=n,a=e-n):(h=e,a=n-e),i>o?(r=o,m=i-o):(r=i,m=o-i),s.action){case"start":this._start();break;case"update":this._update(h,r,a,m);break;case"end":this._end(h,r,a,m,t)}s.stopPropagation()}_redraw(){if(!this._rafId||(this._rafId=null,!this._overlay))return;const{x:s,y:t,width:e,height:i}=this._box;this._updateBox(s,t,e,i),this._updateBackground(s,t,e,i),this._rafId=requestAnimationFrame(this._redraw)}};p([v()],P.prototype,"navigation",void 0),p([v()],P.prototype,"view",null),P=p([L("esri.views.2d.navigation.ZoomBox")],P);const Bt=P;let z=class extends R{constructor(t){super(t),this.animationTime=0,this.momentumEstimator=new yt(500,6,.92),this.momentum=null,this.tmpMomentum=bt(),this.momentumFinished=!1,this.viewpoint=new H({targetGeometry:new j,scale:0,rotation:0}),this._previousDrag=null,dt(()=>this.momentumFinished,()=>this.navigation.stop())}begin(t,e){this.navigation.begin(),this.momentumEstimator.reset(),this.addToEstimator(e),this._previousDrag=e}update(t,e){this.addToEstimator(e);let i=e.center.x,n=e.center.y;const o=this._previousDrag;i=o?o.center.x-i:-i,n=o?n-o.center.y:n,t.viewpoint=X(this.viewpoint,t.viewpoint,[i||0,n||0]),this._previousDrag=e}end(t,e){this.addToEstimator(e);const i=t.navigation.momentumEnabled;this.momentum=i?this.momentumEstimator.evaluateMomentum():null,this.animationTime=0,this.momentum&&this.onAnimationUpdate(t),this._previousDrag=null,this.navigation.end()}addToEstimator(t){const e=t.center.x,i=t.center.y,n=xt(-e,i),o=Tt(-e,i,0);this.momentumEstimator.add(n,o,.001*t.timestamp)}onAnimationUpdate(t){var e;(e=this.navigation.animationManager)==null||e.animateContinous(t.viewpoint,(i,n)=>{const{momentum:o,animationTime:h,tmpMomentum:r}=this,a=.001*n;if(!(this.momentumFinished=!o||o.isFinished(h))){const m=o.valueDelta(h,a);Mt(r,o.direction,m),X(i,i,r),t.constraints.constrainByGeometry(i)}this.animationTime+=a})}stopMomentumNavigation(){this.momentum&&(this.momentumEstimator.reset(),this.momentum=null,this.navigation.stop())}};p([v()],z.prototype,"momentumFinished",void 0),p([v()],z.prototype,"viewpoint",void 0),p([v()],z.prototype,"navigation",void 0),z=p([L("esri.views.2d.navigation.actions.Pan")],z);const Dt=z;let E=class extends R{constructor(t){super(t),this._animationTime=0,this._momentumFinished=!1,this._previousAngle=0,this._previousRadius=0,this._previousCenter=null,this._rotationMomentumEstimator=new St(.6,.15,.95),this._rotationDirection=1,this._startAngle=0,this._startRadius=0,this._updateTimestamp=null,this._zoomDirection=1,this._zoomMomentumEstimator=new $t,this._zoomOnly=null,this.zoomMomentum=null,this.rotateMomentum=null,this.viewpoint=new H({targetGeometry:new j,scale:0,rotation:0}),this.addHandles(dt(()=>this._momentumFinished,()=>this.navigation.stop()))}begin(t,e){this.navigation.begin(),this._rotationMomentumEstimator.reset(),this._zoomMomentumEstimator.reset(),this._zoomOnly=null,this._previousAngle=this._startAngle=e.angle,this._previousRadius=this._startRadius=e.radius,this._previousCenter=e.center,this._updateTimestamp=null,t.constraints.rotationEnabled&&this.addToRotateEstimator(0,e.timestamp),this.addToZoomEstimator(e,1)}update(t,e){this._updateTimestamp===null&&(this._updateTimestamp=e.timestamp);const i=e.angle,n=e.radius,o=e.center,h=Math.abs(180*(i-this._startAngle)/Math.PI),r=Math.abs(n-this._startRadius),a=this._startRadius/n;if(this._previousRadius&&this._previousCenter){const m=n/this._previousRadius;let l=180*(i-this._previousAngle)/Math.PI;this._rotationDirection=l>=0?1:-1,this._zoomDirection=m>=1?1:-1,t.constraints.rotationEnabled?(this._zoomOnly===null&&e.timestamp-this._updateTimestamp>200&&(this._zoomOnly=r-h>0),this._zoomOnly===null||this._zoomOnly?l=0:this.addToRotateEstimator(i-this._startAngle,e.timestamp)):l=0,this.addToZoomEstimator(e,a),this.navigation.setViewpoint([o.x,o.y],1/m,l,[this._previousCenter.x-o.x,o.y-this._previousCenter.y])}this._previousAngle=i,this._previousRadius=n,this._previousCenter=o}end(t){this.rotateMomentum=this._rotationMomentumEstimator.evaluateMomentum(),this.zoomMomentum=this._zoomMomentumEstimator.evaluateMomentum(),this._animationTime=0,(this.rotateMomentum||this.zoomMomentum)&&this.onAnimationUpdate(t),this.navigation.end()}addToRotateEstimator(t,e){this._rotationMomentumEstimator.add(t,.001*e)}addToZoomEstimator(t,e){this._zoomMomentumEstimator.add(e,.001*t.timestamp)}canZoomIn(t){const e=t.scale,i=t.constraints.effectiveMaxScale;return i===0||e>i}canZoomOut(t){const e=t.scale,i=t.constraints.effectiveMinScale;return i===0||e<i}onAnimationUpdate(t){var e;(e=this.navigation.animationManager)==null||e.animateContinous(t.viewpoint,(i,n)=>{const o=!this.canZoomIn(t)&&this._zoomDirection>1||!this.canZoomOut(t)&&this._zoomDirection<1,h=!this.rotateMomentum||this.rotateMomentum.isFinished(this._animationTime),r=o||!this.zoomMomentum||this.zoomMomentum.isFinished(this._animationTime),a=.001*n;if(this._momentumFinished=h&&r,!this._momentumFinished){const m=this.rotateMomentum?Math.abs(this.rotateMomentum.valueDelta(this._animationTime,a))*this._rotationDirection*180/Math.PI:0;let l=this.zoomMomentum?Math.abs(this.zoomMomentum.valueDelta(this._animationTime,a)):1;const c=F(),_=F();if(this._previousCenter){it(c,this._previousCenter.x,this._previousCenter.y),Ct(_,t.size,t.padding),zt(c,c,_);const{constraints:u,scale:d}=t,g=d*l;l<1&&!u.canZoomInTo(g)?(l=d/u.effectiveMaxScale,this.zoomMomentum=null,this.rotateMomentum=null):l>1&&!u.canZoomOutTo(g)&&(l=d/u.effectiveMinScale,this.zoomMomentum=null,this.rotateMomentum=null),Et(i,t.viewpoint,l,m,c,t.size),t.constraints.constrainByGeometry(i)}}this._animationTime+=a})}stopMomentumNavigation(){(this.rotateMomentum||this.zoomMomentum)&&(this.rotateMomentum&&(this._rotationMomentumEstimator.reset(),this.rotateMomentum=null),this.zoomMomentum&&(this._zoomMomentumEstimator.reset(),this.zoomMomentum=null),this.navigation.stop())}};p([v()],E.prototype,"_momentumFinished",void 0),p([v()],E.prototype,"viewpoint",void 0),p([v()],E.prototype,"navigation",void 0),E=p([L("esri.views.2d.navigation.actions.Pinch")],E);const Ft=E,W=F(),mt=F();let N=class extends R{constructor(s){super(s),this._previousCenter=F(),this.viewpoint=new H({targetGeometry:new j,scale:0,rotation:0})}begin(s,t){this.navigation.begin(),it(this._previousCenter,t.center.x,t.center.y)}update(s,t){const{state:{size:e,padding:i}}=s;it(W,t.center.x,t.center.y),Rt(mt,e,i),s.viewpoint=st(this.viewpoint,s.state.paddedViewState.viewpoint,Lt(mt,this._previousCenter,W)),At(this._previousCenter,W)}end(){this.navigation.end()}};p([v()],N.prototype,"viewpoint",void 0),p([v()],N.prototype,"navigation",void 0),N=p([L("esri.views.2d.actions.Rotate")],N);const Vt=N,C=10,ut=1,tt=new H({targetGeometry:new j}),et=[0,0],ct=250;let b=class extends R{constructor(s){super(s),this._endTimer=null,this._lastEventTimestamp=null,this.animationManager=null,this.interacting=!1}initialize(){this.pan=new Dt({navigation:this}),this.rotate=new Vt({navigation:this}),this.pinch=new Ft({navigation:this}),this.zoomBox=new Bt({view:this.view,navigation:this})}destroy(){this.pan=q(this.pan),this.rotate=q(this.rotate),this.pinch=q(this.pinch),this.zoomBox=q(this.zoomBox),this.animationManager=null}begin(){this.stop(),this._set("interacting",!0)}end(){this._lastEventTimestamp=performance.now(),this._startTimer(ct)}async zoom(s,t=this._getDefaultAnchor()){if(this.begin(),this.view.constraints.snapToZoom&&this.view.constraints.effectiveLODs)return s<1?this.zoomIn(t):this.zoomOut(t);this.setViewpoint(t,s,0,[0,0])}async zoomIn(s){const t=this.view,e=t.constraints.snapToNextScale(t.scale);return this._zoomToScale(e,s)}async zoomOut(s){const t=this.view,e=t.constraints.snapToPreviousScale(t.scale);return this._zoomToScale(e,s)}setViewpoint(s,t,e,i){this.begin(),this.view.stateManager.state.viewpoint=this._scaleRotateTranslateViewpoint(this.view.viewpoint,s,t,e,i),this.end()}setViewpointImmediate(s,t=0,e=[0,0],i=this._getDefaultAnchor()){this.view.stateManager.state.viewpoint=this._scaleRotateTranslateViewpoint(this.view.viewpoint,i,s,t,e)}continousRotateClockwise(){var t;const s=this.view.viewpoint;(t=this.animationManager)==null||t.animateContinous(s,e=>{st(e,e,-ut)})}continousRotateCounterclockwise(){var t;const s=this.view.viewpoint;(t=this.animationManager)==null||t.animateContinous(s,e=>{st(e,e,ut)})}resetRotation(){this.view.constraints.rotationEnabled&&(this.view.rotation=0)}continousPanLeft(){this._continuousPan([-C,0])}continousPanRight(){this._continuousPan([C,0])}continousPanUp(){this._continuousPan([0,C])}continousPanDown(){this._continuousPan([0,-C])}continuousPanVector({x:s,y:t}){this._continuousPan([s*C,t*C])}stop(){var s;this.pan.stopMomentumNavigation(),(s=this.animationManager)==null||s.stop(),this.end(),this._endTimer!==null&&(clearTimeout(this._endTimer),this._endTimer=null,this._set("interacting",!1))}_continuousPan(s){var e;const t=this.view.viewpoint;(e=this.animationManager)==null||e.animateContinous(t,i=>{X(i,i,s),this.view.constraints.constrainByGeometry(i)})}_startTimer(s){return this._endTimer!==null||(this._endTimer=setTimeout(()=>{this._endTimer=null;const t=performance.now()-(this._lastEventTimestamp??0);t<ct?this._endTimer=this._startTimer(t):this._set("interacting",!1)},s)),this._endTimer}_getDefaultAnchor(){const{size:s,padding:{left:t,right:e,top:i,bottom:n}}=this.view;return et[0]=.5*(s[0]-e+t),et[1]=.5*(s[1]-n+i),et}async _zoomToScale(s,t=this._getDefaultAnchor()){const{view:e}=this,{constraints:i,scale:n,viewpoint:o,size:h,padding:r}=e,a=i.canZoomInTo(s),m=i.canZoomOutTo(s);if(!(s<n&&!a||s>n&&!m))return ht(tt,o,s/n,0,t,h,r),i.constrainByGeometry(tt),e.goTo(tt,{animate:!0,pickClosestTarget:!1})}_scaleRotateTranslateViewpoint(s,t,e,i,n){const{view:o}=this,{size:h,padding:r,constraints:a,scale:m,viewpoint:l}=o,c=m*e,_=a.canZoomInTo(c),u=a.canZoomOutTo(c);return(e<1&&!_||e>1&&!u)&&(e=1),X(l,l,n),ht(s,l,e,i,t,h,r),a.constrainByGeometry(s)}};p([v()],b.prototype,"animationManager",void 0),p([v({type:Boolean,readOnly:!0})],b.prototype,"interacting",void 0),p([v()],b.prototype,"pan",void 0),p([v()],b.prototype,"pinch",void 0),p([v()],b.prototype,"rotate",void 0),p([v()],b.prototype,"view",void 0),p([v()],b.prototype,"zoomBox",void 0),b=p([L("esri.views.2d.navigation.MapViewNavigation")],b);const oe=b,qt={shaders:{vertexShader:M("magnifier/magnifier.vert"),fragmentShader:M("magnifier/magnifier.frag")},attributes:new Map([["a_pos",0]])};function ae(s){return kt(s,qt)}export{Jt as a,ae as b,qt as c,I as d,Ht as e,oe as f,Kt as n,jt as r,Qt as t};
