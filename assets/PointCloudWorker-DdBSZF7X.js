import{iv as A,v as D,iw as y,bU as c,ix as d,iy as h,iz as $,iA as M,iB as w,iC as I}from"./index-nBWeBKPv.js";import{u as g,c as p,i as O,f as S}from"./PointCloudWorkerUtil-DKUx0snb.js";import"./PointCloudUniqueValueRenderer-C6IR6Qxe.js";import"./I3SBinaryReader-9zrQ0n6f.js";class _{transform(t){const e=this._transform(t),a=[e.points.buffer,e.rgb.buffer];e.pointIdFilterMap!=null&&a.push(e.pointIdFilterMap.buffer);for(const r of e.attributes)"buffer"in r.values&&A(r.values.buffer)&&r.values.buffer!==e.rgb.buffer&&a.push(r.values.buffer);return Promise.resolve({result:e,transferList:a})}_transform(t){const e=g(t.schema,t.geometryBuffer);let a=e.length/3,r=null;const l=new Array,b=p(t.primaryAttributeData,e,a);t.primaryAttributeData!=null&&b&&l.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:b});const o=p(t.modulationAttributeData,e,a);t.modulationAttributeData!=null&&o&&l.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:o});let n=O(t.rendererInfo,b,o,a);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const s=t.filterAttributesData.filter(D).map(f=>{const u=p(f,e,a),m={attributeInfo:f.attributeInfo,values:u};return l.push(m),m});r=new Uint32Array(a),a=S(e,n,r,t.filterInfo,s)}for(const s of t.userAttributesData){const f=p(s,e,a);l.push({attributeInfo:s.attributeInfo,values:f})}3*a<n.length&&(n=new Uint8Array(n.buffer.slice(0,3*a))),this._applyElevationOffsetInPlace(e,a,t.elevationOffset);const i=this._transformCoordinates(e,a,y.fromData(t.obbData),c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obbData:t.obbData,points:i,rgb:n,attributes:l,pointIdFilterMap:r}}_transformCoordinates(t,e,a,r,l){if(!d(t,r,0,t,l,0,e))throw new Error("Can't reproject");const b=h(a.center),o=I(),n=I(),i=h(a.halfSize);$(v,a.quaternion);const s=new Float32Array(3*e);for(let f=0;f<e;f++){let u=3*f;o[0]=t[u]-b[0],o[1]=t[u+1]-b[1],o[2]=t[u+2]-b[2],M(n,o,v),i[0]=Math.max(i[0],Math.abs(n[0])),i[1]=Math.max(i[1],Math.abs(n[1])),i[2]=Math.max(i[2],Math.abs(n[2])),s[u++]=o[0],s[u++]=o[1],s[u]=o[2]}return a.halfSize=i,s}_applyElevationOffsetInPlace(t,e,a){if(a!==0)for(let r=0;r<e;r++)t[3*r+2]+=a}}const v=w();function P(){return new _}export{P as default};
