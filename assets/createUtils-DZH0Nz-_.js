import{hz as H,cG as S,hA as v,aH as B,n as C,j as D,hB as N,hC as E,hD as W,v as I,hE as k,cS as q,hF as J,gi as K,hG as O,hH as Q,cF as V}from"./index-BhDz4nJ7.js";import{w as o}from"./surfaceCoordinateSystems-Bq92ShGB.js";function d(r,t){const s=new V({x:r[0],y:r[1],spatialReference:t});return r.length>2&&(s.z=r[2]),s}function Z(r,t){return new H({points:r,spatialReference:t})}function _(r,t,s){const e=new S({paths:r,spatialReference:t});return s&&v(e),e}function U(r,t,s,e=!0){const l=B(r);l.forEach(n=>{const i=n[0],c=n[n.length-1];C(i,c)&&n.length!==1||n.push(n[0])});let a=new D({rings:l,spatialReference:t});return a.rings.forEach(n=>{N(n)||n.reverse()}),s&&v(a),e&&a.isSelfIntersecting&&E(t)&&(a=W(a)),a}function tt(r,t,s){const e=t.mapToLocalMultiple(r),l=[],a={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y},i=Math.round(n.x-a.x),c=Math.round(n.y-a.y),y=Math.max(Math.abs(i),Math.abs(c));if(s){const u={x:a.x+y,y:a.y+y},h={x:a.x-y,y:a.y-y};l.push(o(u.x,h.y),o(h.x,h.y),o(h.x,u.y),o(u.x,u.y))}else{const u={x:i>0?a.x+y:a.x-y,y:c>0?a.y+y:a.y-y};l.push(o(a.x,a.y),o(u.x,a.y),o(u.x,u.y),o(a.x,u.y))}return A(U([l.map(u=>t.localToMap(u)).filter(I)],t.spatialReference,t.doUnnormalization,!0),l,t)}function at(r,t,s){let e=t.mapToLocalMultiple(r);if(e.length===1){const c=e[0];e=[o(c.x-48,c.y+48),o(c.x+48,c.y-48),o(c.x+48,c.y-48),o(c.x-48,c.y+48)]}const l=[],a={x:e[0].x,y:e[0].y},n={x:e[1].x,y:e[1].y};if(s){const i=Math.round(n.x-a.x),c=Math.round(n.y-a.y);l.push(o(a.x-i,a.y-c),o(n.x,a.y-c),o(n.x,n.y),o(a.x-i,n.y))}else l.push(o(a.x,a.y),o(n.x,a.y),o(n.x,n.y),o(a.x,n.y));return A(U([l.map(i=>t.localToMap(i)).filter(I)],t.spatialReference,t.doUnnormalization,!0),l,t)}function A(r,t,s){const e=w(t[3],t[2],s),l=w(t[1],t[2],s),a=w(t[0],t[1],s),n=w(t[0],t[3],s);return{geometry:r,midpoints:e!=null&&l!=null&&a!=null&&n!=null?{top:e,right:l,bottom:a,left:n}:null}}function w(r,t,s){T[0]=r.x,T[1]=r.y,T[2]=0,b[0]=t.x,b[1]=t.y,b[2]=0,k(T,T,b,.5),z.x=T[0],z.y=b[1],z.z=b[2];const e=s.localToMap(z);return e!=null?d(e,s.spatialReference):null}const z=o(0,0,0),T=q(),b=q();function nt(r,t,s,e){const l=t.mapToLocalMultiple(r);let a=null,n=null;if(s)a=l[0],n=l[1];else{const x=l[0],p=l[1],R=Math.round(p.x-x.x),g=Math.round(p.y-x.y),f=Math.max(Math.abs(R),Math.abs(g));a=o(R>0?x.x+f/2:x.x-f/2,g>0?x.y+f/2:x.y-f/2),n=o(Math.abs(R)>Math.abs(g)?a.x-f/2:a.x,Math.abs(R)>Math.abs(g)?a.y:a.y-f/2)}const i=t.localToMap(a),c=t.localToMap(n);if(i==null||c==null)return null;t.doUnnormalization&&J([[i,c]],t.spatialReference);const y=d(i,t.spatialReference),u=d(c,t.spatialReference),h=K(t.spatialReference);let M=0;if(E(t.spatialReference))M=h*O(y,u,null);else{const x=a.x-n.x,p=a.y-n.y;M=h*Math.sqrt(x*x+p*p)*(e||1)}const $=new Q({center:y,radius:M,radiusUnit:"meters",spatialReference:t.spatialReference});return{geometry:U($.rings,$.spatialReference,!1),center:y,edge:u}}function et(r,t,s){const e=t.mapToLocalMultiple(r),l=e[0],a=e[1],n=Math.round(a.x-l.x),i=Math.round(a.y-l.y),c=o(s?l.x:l.x+n/2,s?l.y:l.y+i/2),y=s?n:n/2,u=s?i:i/2,h=60,M=[],$=2*Math.PI/h;function x(m){const F=Math.cos(m),G=Math.sin(m);return o(y*F+c.x,u*G+c.y)}for(let m=0;m<h;m++)M.push(x(m*$));M.push(M[0]);const{spatialReference:p,doUnnormalization:R}=t,g=U([M.map(m=>t.localToMap(m)).filter(I)],p,R,!1),f=t.localToMap(x(Math.PI/2)),P=t.localToMap(x(0)),L=t.localToMap(x(-Math.PI/2)),j=t.localToMap(x(Math.PI));return{geometry:g,midpoints:f!=null&&P!=null&&L!=null&&j!=null?{top:d(f,p),right:d(P,p),bottom:d(L,p),left:d(j,p)}:null}}export{nt as L,_ as R,tt as T,at as b,Z as d,U as j,et as v};
